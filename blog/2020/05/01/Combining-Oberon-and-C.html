<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Combining Oberon-7 and C with OBNC</title>

    <link rel="stylesheet" type="text/css"  href="/css/site.css" media="screen" />
    <link rel="stylesheet" type="text/css"  href="/css/tables.css" media="screen" />
    <link title="RSS feed for rsdoiel's blog" rel="alternate" type="application/rss+xml" href="http://rsdoiel.github.io/rss.xml" />
    <link rel="alternative" type="application/markdown" href="Combining-Oberon-and-C.md">
  </head>
  <body>
    
    <nav>
    <ul>
<li><a href="/">R. S. Doiel</a></li>
<li><a href="/blog/">Blog</a></li>
<li><a href="/presentations.html">Presentations</a></li>
<li><a href="/library-terminology.html">Library Jargon</a></li>
<li><a href="/cv.html">CV</a></li>
<li><a href="/resume.html">Resume</a></li>
<li><a href="https://github.com/rsdoiel">GitHub</a></li>
</ul>

    </nav>

    <section>
      <article>
	  <h1 id="combining-oberon-7-and-c-with-obnc">Combining Oberon-7 and C with OBNC</h1>

<p>By R. S. Doiel, 2020-05-01</p>

<p>In my day job I write allot of code in Go and
orchestration code in Python.  It's nice having
the convenience of combining code written one
language with an another.  You can do the same
with <a href="https://miasap.se/obnc/">OBNC</a>.  The OBNC
compiler supports inclusion of C code in a
straight forward manner. In fact Karl's compiler
will generate the C file for you!</p>

<p>In learning how to combine C code and Oberon-7
I started by reviewing Karl's <a href="https://miasap.se/obnc/man/obnc.txt">manual page</a>.
The bottom part of that manual page describes
the steps I will repeat below. The description
sounds more complicated but when you walk through
the steps it turns out to be pretty easy.</p>

<h2 id="basic-process">Basic Process</h2>

<p>Creating a C extension for use with OBNC is very
straight forward.</p>

<ol>
<li>Create a Oberon module with empty exported procedures</li>
<li>Create a Oberon test module that uses your module</li>
<li>Compile your test module with OBNC</li>
<li>Copy the generated module <code>.c</code> file to the same directory as your Oberon module source</li>
<li>Fill in the skeleton <code>.c</code> and re-compile and test</li>
</ol>

<p>Five steps may sound complicated but in practice is
straight forward.</p>

<h2 id="fmt-an-example">Fmt, an example</h2>

<p>In my demonstration of Karl's instructions I will be
creating a module named <code>Fmt</code> that includes two
procedures <code>Int()</code> and <code>Real()</code> that let you use
a C-style format string to format an INTEGER
or REAL as an ARRAY OF CHAR. We retain the idiomatic
way Oberon works with types but allow a little more
flexibility in how the numbers are converted and
rendered as strings.</p>

<h3 id="step-1">Step 1</h3>

<p>Create <a href="Fmt.Mod">Fmt.Mod</a> defining two exported procedures
<code>Int*()</code> and <code>Real*()</code>. The procedures body should be
empty. Karl's practice is to use exported comments to
explain the procedures.</p>

<pre><code class="language-Oberon">    MODULE Fmt;
      CONST
        Version* = &quot;v0.0.0&quot;;
    
    (**Procedure for getting the epoch time value *)
    
    (*implemented in C*)
    
    	PROCEDURE Int*(value : INTEGER; fmt: ARRAY OF CHAR; VAR dest : ARRAY OF CHAR);
    (**Int*() takes a value (INTEGER), a format string (ARRAY OF CHAR) and updates dest (ARRAY OF CHAR)
    using C's sprintf function. *)
    	END Int;
    
    	PROCEDURE Real*(value : REAL; fmt: ARRAY OF CHAR; VAR dest : ARRAY OF CHAR);
    (**Int*() takes a value (REAL), a format string (ARRAY OF CHAR) and updates dest (ARRAY OF CHAR)
    using C's sprintf function. *)
    	END Real;
    
    BEGIN
    END Fmt.
</code></pre>

<h3 id="step-2">Step 2</h3>

<p>Create a test module, <a href="FmtTest.Mod">FmtTest.Mod</a>, for
<a href="Fmt.Mod">Fmt.Mod</a>.</p>

<pre><code class="language-Oberon">    MODULE FmtTest;
      IMPORT Out, Fmt;
    
    PROCEDURE TestInt(): BOOLEAN;
      VAR
        fmtString : ARRAY 24 OF CHAR;
        dest : ARRAY 128 OF CHAR;
        i : INTEGER;
    BEGIN
        i := 42;
        fmtString := &quot;%d&quot;;
        Fmt.Int(i, fmtString, dest);
        Out.String(dest);Out.Ln;
        RETURN TRUE
    END TestInt;
    
    PROCEDURE TestReal(): BOOLEAN;
      VAR
        fmtString : ARRAY 24 OF CHAR;
        dest : ARRAY 128 OF CHAR;
        r : REAL;
    BEGIN
        r := 3.145;
        fmtString := &quot;%d&quot;;
        Fmt.Real(r, fmtString, dest);
        Out.String(dest);Out.Ln;
        RETURN TRUE
    END TestReal;
    
    BEGIN
      ASSERT(TestInt());
      ASSERT(TestReal());
      Out.String(&quot;Success!&quot;);Out.Ln;
    END FmtTest.
</code></pre>

<h3 id="step-3">Step 3</h3>

<p>Generate a new <a href="Fmt.c">Fmt.c</a> by using the
OBNC compiler.</p>

<pre><code class="language-shell">    obnc FmtTest.Mod
    mv .obnc/Fmt.c ./
</code></pre>

<p>the file <code>.obnc/Fmt.c</code> is your C template file. Copy it
to the directory where Fmt.Mod is.</p>

<h3 id="step-4">Step 4</h3>

<p>Update the skeleton <code>Fmt.c</code> with the necessary C code.
Here's what OBNC generated version.</p>

<pre><code class="language-c">    /*GENERATED BY OBNC 0.16.1*/
    
    #include &quot;Fmt.h&quot;
    #include &lt;obnc/OBNC.h&gt;
    
    #define OBERON_SOURCE_FILENAME &quot;Fmt.Mod&quot;
    
    void Fmt__Int_(OBNC_INTEGER value_, const char fmt_[], OBNC_INTEGER fmt_len, char dest_[], OBNC_INTEGER dest_len)
    {
    }
    
    
    void Fmt__Real_(OBNC_REAL value_, const char fmt_[], OBNC_INTEGER fmt_len, char dest_[], OBNC_INTEGER dest_len)
    {
    }
    
    
    void Fmt__Init(void)
    {
    }
</code></pre>

<p>Here's the skeleton revised with do what we need to be done.</p>

<pre><code class="language-c">    #include &quot;.obnc/Fmt.h&quot;
    #include &lt;obnc/OBNC.h&gt;
    #include &lt;stdio.h&gt;
    
    #define OBERON_SOURCE_FILENAME &quot;Fmt.Mod&quot;
    
    void Fmt__Int_(OBNC_INTEGER value_, const char fmt_[], OBNC_INTEGER fmt_len, char dest_[], OBNC_INTEGER dest_len)
    {
        sprintf(dest_, fmt_, value_);
    }
    
    
    void Fmt__Real_(OBNC_REAL value_, const char fmt_[], OBNC_INTEGER fmt_len, char dest_[], OBNC_INTEGER dest_len)
    {
        sprintf(dest_, fmt_, value_);
    }
    
    
    void Fmt__Init(void)
    {
    }
</code></pre>

<p>NOTE: You need to change the path for the <code>Fmt.h</code> file reference.
I also add the <code>stdio.h</code> include so I have access to the C
function I wish to use. Also notice how OBNC the signature
for the functions use the <code>_</code> character to identify mapped values
as well as the char arrays being provided with a length parameter.
If you are doing more extensive string work you'll want to take
advantage of these additional parameters so insure that the
as strings are terminated properly for Oberon's reuse.</p>

<h3 id="step-5">Step 5</h3>

<p>Recompile and test.</p>

<pre><code class="language-shell">    obnc FmtTest.Mod
    ./FmtTest
</code></pre>

      </article>
    </section>

    <footer>
    <p>copyright Â© 2016 - 2020 R. S. Doiel<br />
<a href="/rssfeed.html">RSS</a> feed and website built with <a href="https://caltechlibrary.github.io/mkpage">mkpage</a>, <a href="https://caltechlibrary.github.io/datatools">datatools</a>, Bash and Make.</p>

    </footer>
    
<!-- START: PrettyFi from https://github.com/google/code-prettify -->
<script>
/* We want to add the class "prettyprint" to all the pre elements */
var pre_list = document.querySelectorAll("pre");

pre_list.forEach(function(elem) {
    elem.classList.add("prettyprint");
    elem.classList.add("linenums");/**/
    elem.classList.add("json"); /**/
});
</script>
<style>
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    color: #555;
    list-style-type: decimal;
}
</style>
<link rel="stylesheet" type="text/css" href="/css/prettify.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_
prettify.js"></script>
<!--  END: PrettyFi from https://github.com/google/code-prettify -->

    </body>
</html>
