<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Portable Oberon 7</title>

    <link rel="stylesheet" type="text/css"  href="/css/site.css" media="screen" />
    <link rel="stylesheet" type="text/css"  href="/css/tables.css" media="screen" />
    <link title="RSS feed for rsdoiel's blog" rel="alternate" type="application/rss+xml" href="http://rsdoiel.github.io/rss.xml" />
    <link rel="alternative" type="application/markdown" href="Portable-Oberon-7.md">
  </head>
  <body>
    <nav>
    <ul>
    <li>
    <a href="/">R. S. Doiel</a>
    </li>
    <li>
    <a href="/blog/">Blog</a>
    </li>
    <li>
    <a href="/presentations.html">Presentations</a>
    </li>
    <li>
    <a href="/library-terminology.html">Library Jargon</a>
    </li>
    <li>
    <a href="/cv.html">CV</a>
    </li>
    <li>
    <a href="/resume.html">Resume</a>
    </li>
    <li>
    <a href="https://github.com/rsdoiel">GitHub</a>
    </li>
    </ul>
    </nav>

    <section>
      <article>
	  <h1>
   Portable Oberon 7
   </h1>
   <h2>
   using OBNC modules
   </h2>
   <p>
   This is the eleventh post in the <a href="../../04/11/Mostly-Oberon.html">Mostly Oberon</a> series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.
   </p>
   <h2>
   Working with standard input
   </h2>
   <p>
   By R. S. Doiel, 2020-08-15
   </p>
   <p>
   Karl’s <a href="https://miasap.se/obnc/">OBNC</a> Oberon-7 compiler provides the Oberon-2 set of portable Oberon modules as well as several very useful additions making Oberon-7 suitable for writing programs in a POSIX environment. We’re going to explore several of those modules in this post as we create a program called <a href="SlowCat.Mod">SlowCat</a>. I am using the term “Portable” to mean the code can be compiled using OBNC on macOS, Linux, and Raspberry Pi OS. It may even work on Windows 10 (might need the Linux sub-system enabled). There is an older concept of “Portable Oberon” which is related to the Oakwood Guide Lines for Oberon-2 compilers. I’ll leave that discussion along with <a href="http://www.fim.uni-linz.ac.at/pow/pow.htm">POW!</a> to the end of this post.
   </p>
   <h3>
   SlowCat
   </h3>
   <p>
   Recently while I was reviewing logs at work using <a href="https://en.wikipedia.org/wiki/Cat_(Unix)">cat</a>, <a href="https://en.wikipedia.org/wiki/Grep">grep</a> and <a href="https://en.wikipedia.org/wiki/More_(command)">more</a> it struck me that it would have been nice if <strong>cat</strong> or <strong>more</strong> came with a time delay so you could use them like a teleprompter. This would let you casually watch the file scroll by while still being able to read the lines. The program we’ll build in this post is “SlowCat” which accepts a command line parameter indicating the delay in seconds between display each line read from standard input.
   </p>
   <h2>
   Working with Standard Input, Out
   </h2>
   <p>
   The Oakwood guides for Oberon-2 describe two modules particularly useful for working with standard input and output. They are appropriately called <code>In</code> and <code>Out</code>. On many Oberon Systems these have been implemented such that your code could run under Unix or Oberon System with a simple re-compile. We’ve used <code>Out</code> in our first program of this series, “Hello World”. It provides a means to write Oberon system base types to standard out. We’ve used <code>In</code> a few times too. But <code>In</code> is worth diving into a bit more.
   </p>
   <h3>
   In
   </h3>
   <p>
   The <a href="http://miasap.se/obnc/obncdoc/basic/In.def.html">In</a> module provides a mirror of inputs to those of <a href="http://miasap.se/obnc/obncdoc/basic/Out.def.html">Out</a>. In Karl’s implementation we are interested in one procedure and module status variable.
   </p>
   <ul>
   <li>
   <code>In.Line(VAR line: ARRAY OF CHAR)</code> : Read a sequence of characters from standard input from the current position in the file to the end of line.
   </li>
   <li>
   <code>In.Done</code> : Is a status Boolean variable, if the last call to an procedure in <code>In</code> was successful then it is set TRUE, otherwise FALSE (e.g. we’re out the end of a file)
   </li>
   </ul>
   <p>
   We use Karl’s <code>In.Line()</code> extension to the standard <code>In</code> implementation before and will do so again as it simplifies our code and keeps things easily readable.
   </p>
   <p>
   There is one nuance with <code>In.Done</code> that is easy to get tripped up on.<br /> <code>In.Done</code> indicates if the last operation was successful. So if you’re using <code>In.Line()</code> then <code>In.Done</code> should be true if reading the line was successful. If you hit the end of the file then <code>In.Done</code> should be false. When you write your loop this can be counter intuitive. Here is a example of testing <code>In.Done</code> with a repeat until loop.
   </p>
   <pre class="Oberon7"><code>    REPEAT
         In.Line(text);
         IF In.Done THEN
           Out.String(text);Out.Ln();
         END;
       END In.Done = FALSE;</code></pre>
   <p>
   So when you read this it is easy to think of <code>In.Done</code> as you’re done reading from standard input but actually we need to check for <code>FALSE</code>. The value of <code>In.Done</code> was indicating the success of reading our line. An unsuccessful line read, meaning we’re at the end of the file, sets <code>In.Done</code> to false!
   </p>
   <h3>
   Out
   </h3>
   <p>
   As mention <code>Out</code> provides our output functions. We’ll be using two procedure from <code>Out</code>, namely <code>Out.String()</code> and <code>Out.Ln()</code>. We’ve seen both before.
   </p>
   <h3>
   Input0
   </h3>
   <p>
   There are other input modules provided by Karl that are not listed in the Oakwood guide lines.Basically these consist of lower level abstractions necessary to mask the vagaries of the POSIX systems. You probably will not find the same modules available when using other Oberon compilers. I don’t often use <code>Input0</code> directly but in “SlowCat” I do need to use <code>Input0.Time</code> procedure. <code>Input0</code> provides “Time” which let’s you read the epoch value provided by Unix. I am using this to create a a busy wait delay between displaying lines of text.
   </p>
   <h2>
   Working with Karl’s extensions
   </h2>
   <p>
   Karl provides a number of extension module wrapping various POSIX calls. We are going to use two, <a href="http://miasap.se/obnc/obncdoc/ext/extArgs.def.html">extArgs</a> which provides access to command line args and <a href="http://miasap.se/obnc/obncdoc/ext/extConvert.def.html">extConvert</a> which provides a means of converting strings to integers.
   </p>
   <h2>
   Our Algorithm
   </h2>
   <p>
   To create “SlowCat” we need four procedures and one global variable.
   </p>
   <ul>
   <li>
   <code>Usage()</code> display a help text if parameters don’t make sense
   </li>
   <li>
   <code>ProcessArgs()</code> to get our delay time from the command line
   </li>
   <li>
   `Delay(count : INTEGER)
   </li>
   <li>
   <code>SlowCat(count : INTEGER)</code> take standard input and display like a teleprompter
   </li>
   <li>
   <code>count</code> is an integer holding our delay value (seconds of waiting) which is set by ProcessArgs()
   </li>
   </ul>
   <h3>
   Usage
   </h3>
   <p>
   Usage just wraps helpful text and display it to standard out.
   </p>
   <h2>
   ProcessArgs()
   </h2>
   <p>
   This procedure uses two of Karl’s extension modules to retrieve the since command line parameter and convert the string value retrieved into an integer. <code>ProcessArgs()</code> return TRUE if we can successful convert the command line parameter and set the value of count otherwise return FALSE.
   </p>
   <h2>
   Delay(VAR count : INTEGER)
   </h2>
   <p>
   This procedure uses <code>Input0</code> to fetch the current epoch time and counts the number of seconds until we’ve reached our delay value. It’s a busy loop which isn’t ideal but does keep the program simple.
   </p>
   <h2>
   SlowCat(VAR count: INTEGER);
   </h2>
   <p>
   This is the heart of our command line program. It reads a line of text from standard input, if successful writes it to standard out and then waits using delay before repeating this process. The delay is only invoked when a reading a line was successful.
   </p>
   <h2>
   Putting it all together
   </h2>
   <p>
   Here’s a “SlowCat” program.
   </p>
   <pre><code>    MODULE SlowCat;
         IMPORT In, Out, Input0, Args := extArgs, Convert := extConvert;
       
       CONST
         MAXLINE = 1024;
       
       VAR
         count: INTEGER;
       
       PROCEDURE Usage();
       BEGIN
         Out.String(&quot;USAGE:&quot;);Out.Ln();
         Out.Ln();
         Out.String(&quot;SlowCat outputs lines of text delayed by&quot;);Out.Ln();
         Out.String(&quot;a number of seconds. It takes one parameter,&quot;);Out.Ln();
         Out.String(&quot;an integer, which is the number of seconds to&quot;);Out.Ln();
         Out.String(&quot;delay a line of output.&quot;);Out.Ln();
         Out.String(&quot;SlowCat works on standard input and output.&quot;);Out.Ln();
         Out.Ln();
         Out.String(&quot;EXAMPLE:&quot;);
         Out.Ln();
         Out.String(&quot;    SlowCat 15 &lt; README.md&quot;);Out.Ln();
         Out.Ln();  
       END Usage;
       
       PROCEDURE ProcessArgs() : BOOLEAN;
         VAR i : INTEGER; ok : BOOLEAN; arg : ARRAY MAXLINE OF CHAR;
             res : BOOLEAN;
       BEGIN
         res := FALSE;
         IF Args.count = 1 THEN
           Args.Get(0, arg, i);
           Convert.StringToInt(arg, i, ok);
           IF ok THEN
              (* convert seconds to microseconds of clock *)
              count := (i * 1000);
              res := TRUE;
           END;
         END;
         RETURN res
       END ProcessArgs;
       
       PROCEDURE Delay*(count : INTEGER);
         VAR start, current, delay : INTEGER;
       BEGIN
          start := Input0.Time();
          REPEAT
            current := Input0.Time();
            delay := (current - start);
          UNTIL delay &gt;= count;
       END Delay;
       
       PROCEDURE SlowCat(count : INTEGER);
         VAR text : ARRAY MAXLINE OF CHAR;
       BEGIN
         REPEAT
           In.Line(text);
           IF In.Done THEN
             Out.String(text);Out.Ln();
             (* Delay by count *)
             Delay(count);
           END;
         UNTIL In.Done = FALSE;
       END SlowCat;
       
       BEGIN
         count := 0;
         IF ProcessArgs() THEN
           SlowCat(count);
         ELSE
           Usage();
         END;
       END SlowCat.</code></pre>
   <h2>
   Compiling and trying it out
   </h2>
   <p>
   To compile our program and try it out reading our source code do the following.
   </p>
   <pre><code>    obnc SlowCat.Mod
       # If successful
       ./SlowCat 2 &lt; SlowCat.Mod</code></pre>
   <h2>
   Oakwood Guidelines and POW!
   </h2>
   <p>
   Oberon and Oberon-2 were both used in creating and enhancing the Oberon System(s) as well as for writing programs on POSIX and Windows systems. Implementing Oberon on non Oberon Systems meant creating new compilers. The Oakwood Guidelines were an agreement between some of the important Oberon-2 compiler implementer that fill in the gaps between specification, implementation and host operating systems. They were intended to allow programs (and students) to compile and run their Oberon programs with minimal modification in any environment where a compliant compiler was available.
   </p>
   <p>
   POW! was a different approach. It was a compiler and IDE targeting other than Oberon Systems (e.g. Windows and later Java). It was intended to be used in a hybrid development environment. It too proposed a common set of modules but went beyond those suggested in the Oakwood Guidelines.
   </p>
   <p>
   These are interest to Oberon-7 users in that it remains desirable to easily run our code on POSIX systems (the topic of this series of articles) but also possibly on Project Oberon System 2013.
   </p>
   <p>
   Finding documentation about Oakwood is sketchy and will likely fade from the internet. I was able to find a PDF of the 1995 version of the guidelines at http://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf
   </p>
   <h3>
   Previous
   </h3>
   <ul>
   <li>
   <p>
   Previous <a href="../..//07/07/Procedures-in-records.html">Procedures in records</a>
   </p>
   </li>
   </ul>
      </article>
    </section>

    <footer>
    <p>
    copyright © 2016 - 2020 R. S. Doiel<br /> <a href="/rssfeed.html">RSS</a> feed and website built with <a href="https://caltechlibrary.github.io/mkpage">mkpage</a>, <a href="https://caltechlibrary.github.io/datatools">datatools</a>, Bash and Make.
    </p>
    </footer>
<!-- START: PrettyFi from https://github.com/google/code-prettify -->
<script>
/* We want to add the class "prettyprint" to all the pre elements */
var pre_list = document.querySelectorAll("pre");

pre_list.forEach(function(elem) {
    elem.classList.add("prettyprint");
    elem.classList.add("linenums");/**/
    elem.classList.add("json"); /**/
});
</script>
<style>
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    color: #555;
    list-style-type: decimal;
}
</style>
<link rel="stylesheet" type="text/css" href="/css/prettify.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_
prettify.js"></script>
<!--  END: PrettyFi from https://github.com/google/code-prettify -->

    </body>
</html>
