<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Portable Oberon 7</title>

    <link rel="stylesheet" type="text/css"  href="/css/site.css" media="screen" />
    <link rel="stylesheet" type="text/css"  href="/css/tables.css" media="screen" />
    <link title="RSS feed for rsdoiel's blog" rel="alternate" type="application/rss+xml" href="http://rsdoiel.github.io/rss.xml" />
    <link rel="alternative" type="application/markdown" href="Portable-Oberon-7.md">
  </head>
  <body>
    <nav>
    <ul>
    <li>
    <a href="/">R. S. Doiel</a>
    </li>
    <li>
    <a href="/blog/">Blog</a>
    </li>
    <li>
    <a href="/presentations.html">Presentations</a>
    </li>
    <li>
    <a href="/library-terminology.html">Library Jargon</a>
    </li>
    <li>
    <a href="/cv.html">CV</a>
    </li>
    <li>
    <a href="/resume.html">Resume</a>
    </li>
    <li>
    <a href="https://github.com/rsdoiel">GitHub</a>
    </li>
    </ul>
    </nav>

    <section>
      <article>
	  <h1 id="portable-oberon-7">
   Portable Oberon 7
   </h1>
   <h2 id="using-obnc-modules">
   using OBNC modules
   </h2>
   <p>
   This is the eleventh post in the <a href="../../04/11/Mostly-Oberon.html">Mostly Oberon</a> series. Mostly Oberon documents my exploration of the Oberon Language, Oberon System and the various rabbit holes I will inevitably fall into.
   </p>
   <h2 id="working-with-standard-input">
   Working with standard input
   </h2>
   <p>
   By R. S. Doiel, 2020-08-15
   </p>
   <p>
   Karl’s <a href="https://miasap.se/obnc/">OBNC</a> Oberon-7 compiler provides the Oberon-2 set of portable Oberon modules as well as several very useful additions making Oberon-7 suitable for writing programs in a POSIX environment. We’re going to explore several of those modules in this post as we create a program called <a href="SlowCat.Mod">SlowCat</a>.
   </p>
   <h3 id="slowcat">
   SlowCat
   </h3>
   <p>
   Recently while I was reviewing logs at work using <a href="https://en.wikipedia.org/wiki/Cat_(Unix)">cat</a>, <a href="https://en.wikipedia.org/wiki/Grep">grep</a> and <a href="https://en.wikipedia.org/wiki/More_(command)">more</a> it struck me that it would have been nice if <strong>cat</strong> or <strong>more</strong> came with a time delay so you could use them like a teleprompter. This would let you casually watch the file scroll by while still being able to read the lines. The program we’ll build in this post is “SlowCat” which accepts a command line parameter indicating the delay in seconds between display each line read from standard input.
   </p>
   <h2 id="working-with-standard-input-out">
   Working with Standard Input, Out
   </h2>
   <p>
   The Oakwood guides for Oberon-2 describe two modules particularly useful for working with standard input and output. They are appropriately called <code>In</code> and <code>Out</code>. On may Oberon Systems these have been implemented such that your code could run under Unix or Oberon System with a simple re-compile. We’ve used <code>Out</code> in our first program of this series, “Hello World”. It provides a means to write Oberon system base types to standard out. We’ve used <code>In</code> a few times too. But <code>In</code> is worth diving into a bit more.
   </p>
   <h3 id="in">
   In
   </h3>
   <p>
   The <a href="http://miasap.se/obnc/obncdoc/basic/In.def.html">In</a> module provides a mirror of inputs to those of <a href="http://miasap.se/obnc/obncdoc/basic/Out.def.html">Out</a>. In Karl’s implementation we are interested in one procedure and module status variable.
   </p>
   <ul>
   <li>
   <code>In.Line(VAR line: ARRAY OF CHAR)</code> : Read a sequence of characters from standard input from the current position in the file to the end of line.
   </li>
   <li>
   <code>In.Done</code> : Is a status Boolean variable, if the last call to an procedure in <code>In</code> was successful then it is set TRUE, otherwise FALSE (e.g. we’re out the end of a file)
   </li>
   </ul>
   <p>
   We use Karl’s <code>In.Line()</code> extension to the standard <code>In</code> implementation before and will do so again as it simplifies our code and keeps things easily readable.
   </p>
   <p>
   There is one nuance with <code>In.Done</code> that is easy to get tripped up on.<br /> <code>In.Done</code> indicates if the last operation was successful. So if you’re using <code>In.Line()</code> then <code>In.Done</code> should be true if reading the line was successful. If you hit the end of the file then <code>In.Done</code> should be false. When you write your loop this can be counter intuitive. Here is a example of testing <code>In.Done</code> with a repeat until loop.
   </p>
   <pre class="oberon7"><code>    REPEAT
         In.Line(text);
         IF In.Done THEN
           Out.String(text);Out.Ln();
         END;
       END In.Done = FALSE;</code></pre>
   <p>
   So when you read this it is easy to think of <code>In.Done</code> as you’re done reading from standard input but actually we need to check for <code>FALSE</code>. The value of <code>In.Done</code> was indicating the success of reading our line. An unsuccessful line read, meaning we’re at the end of the file, sets <code>In.Done</code> to false!
   </p>
   <h3 id="input0">
   Input0
   </h3>
   <p>
   There are other input modules provided by Karl that are listed in the Oakwood guides. Basically these consist of lower level abstractions necessary to mask the vagaries of the host system. Generally I don’t use them directly for basic text processing programs but in “SlowCat” I do need to use <code>Input0</code>. <code>Input0</code> provides one unexpected helpful procedure called “Time” which let’s you read the epoch value provided by Unix. We are going to use this for creating a busy wait delay between displaying our lines of text.
   </p>
   <h3 id="out">
   Out
   </h3>
   <p>
   As mention <code>Out</code> provides our output functions. We’ll be using two procedure from <code>Out</code>, namely <code>Out.String()</code> and <code>Out.Ln()</code>. We’ve seen both before.
   </p>
   <h2 id="working-with-karls-extensions">
   Working with Karl’s extensions
   </h2>
   <p>
   Karl provides a number of extension module wrapping various POSIX calls. We are going to use two, <a href="http://miasap.se/obnc/obncdoc/ext/extArgs.def.html">extArgs</a> which provides access to command line args and <a href="http://miasap.se/obnc/obncdoc/ext/extConvert.def.html">extConvert</a> which provides a means of converting strings to integers.
   </p>
   <h2 id="our-algorithm">
   Our Algorithm
   </h2>
   <p>
   To create “SlowCat” we need four procedures and one global variable.
   </p>
   <ul>
   <li>
   <code>Usage()</code> display a help text if parameters don’t make sense
   </li>
   <li>
   <code>ProcessArgs()</code> to get our delay time from the command line
   </li>
   <li>
   `Delay(count : INTEGER)
   </li>
   <li>
   <code>SlowCat(count : INTEGER)</code> take standard input and display like a teleprompter
   </li>
   <li>
   <code>count</code> is an integer holding our delay value (seconds of waiting) which is set by ProcessArgs()
   </li>
   </ul>
   <h3 id="usage">
   Usage
   </h3>
   <p>
   Usage just wraps helpful text and display it to standard out.
   </p>
   <h2 id="processargs">
   ProcessArgs()
   </h2>
   <p>
   This procedure uses two of Karl’s extension modules to retrieve the since command line parameter and convert the string value retrieved into an integer. <code>ProcessArgs()</code> return TRUE if we can successful convert the command line parameter and set the value of count otherwise return FALSE.
   </p>
   <h2 id="delayvar-count-integer">
   Delay(VAR count : INTEGER)
   </h2>
   <p>
   This procedure uses <code>Input0</code> to fetch the current epoch time and counts the number of seconds until we’ve reached our delay value. It’s a busy loop which isn’t ideal but does keep the program simple.
   </p>
   <h2 id="slowcatvar-count-integer">
   SlowCat(VAR count: INTEGER);
   </h2>
   <p>
   This is the heart of our command line program. It reads a line of text from standard input, if successful writes it to standard out and then waits using delay before repeating this process. The delay is only invoked when a reading a line was successful.
   </p>
   <h2 id="putting-it-all-together">
   Putting it all together
   </h2>
   <p>
   Here’s a “SlowCat” program.
   </p>
   <pre><code>    MODULE SlowCat;
         IMPORT In, Out, Input0, Args := extArgs, Convert := extConvert;
       
       CONST
         MAXLINE = 1024;
       
       VAR
         count: INTEGER;
       
       PROCEDURE Usage();
       BEGIN
         Out.String(&quot;USAGE:&quot;);Out.Ln();
         Out.Ln();
         Out.String(&quot;SlowCat outputs lines of text delayed by&quot;);Out.Ln();
         Out.String(&quot;a number of seconds. It takes one parameter,&quot;);Out.Ln();
         Out.String(&quot;an integer, which is the number of seconds to&quot;);Out.Ln();
         Out.String(&quot;delay a line of output.&quot;);Out.Ln();
         Out.String(&quot;SlowCat works on standard input and output.&quot;);Out.Ln();
         Out.Ln();
         Out.String(&quot;EXAMPLE:&quot;);
         Out.Ln();
         Out.String(&quot;    SlowCat 15 &lt; README.md&quot;);Out.Ln();
         Out.Ln();  
       END Usage;
       
       PROCEDURE ProcessArgs() : BOOLEAN;
         VAR i : INTEGER; ok : BOOLEAN; arg : ARRAY MAXLINE OF CHAR;
             res : BOOLEAN;
       BEGIN
         res := FALSE;
         IF Args.count = 1 THEN
           Args.Get(0, arg, i);
           Convert.StringToInt(arg, i, ok);
           IF ok THEN
              (* convert seconds to microseconds of clock *)
              count := (i * 1000);
              res := TRUE;
           END;
         END;
         RETURN res
       END ProcessArgs;
       
       PROCEDURE Delay*(count : INTEGER);
         VAR start, current, delay : INTEGER;
       BEGIN
          start := Input0.Time();
          REPEAT
            current := Input0.Time();
            delay := (current - start);
          UNTIL delay &gt;= count;
       END Delay;
       
       PROCEDURE SlowCat(count : INTEGER);
         VAR text : ARRAY MAXLINE OF CHAR;
       BEGIN
         REPEAT
           In.Line(text);
           IF In.Done THEN
             Out.String(text);Out.Ln();
             (* Delay by count *)
             Delay(count);
           END;
         UNTIL In.Done = FALSE;
       END SlowCat;
       
       BEGIN
         count := 0;
         IF ProcessArgs() THEN
           SlowCat(count);
         ELSE
           Usage();
         END;
       END SlowCat.</code></pre>
   <h2 id="compiling-and-trying-it-out">
   Compiling and trying it out
   </h2>
   <p>
   To compile our program and try it out reading our source code do the following.
   </p>
   <pre><code>    obnc SlowCat.Mod
       # If successful
       ./SlowCat 2 &lt; SlowCat.Mod</code></pre>
   <h3 id="previous">
   Previous
   </h3>
   <ul>
   <li>
   Previous <a href="../..//07/07/Procedures-in-records.html">Procedures in records</a>
   </li>
   </ul>
      </article>
    </section>

    <footer>
    <p>
    copyright © 2016 - 2020 R. S. Doiel<br /> <a href="/rssfeed.html">RSS</a> feed and website built with <a href="https://caltechlibrary.github.io/mkpage">mkpage</a>, <a href="https://caltechlibrary.github.io/datatools">datatools</a>, Bash and Make.
    </p>
    </footer>
<!-- START: PrettyFi from https://github.com/google/code-prettify -->
<script>
/* We want to add the class "prettyprint" to all the pre elements */
var pre_list = document.querySelectorAll("pre");

pre_list.forEach(function(elem) {
    elem.classList.add("prettyprint");
    elem.classList.add("linenums");/**/
    elem.classList.add("json"); /**/
});
</script>
<style>
li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9
{
    color: #555;
    list-style-type: decimal;
}
</style>
<link rel="stylesheet" type="text/css" href="/css/prettify.css">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_
prettify.js"></script>
<!--  END: PrettyFi from https://github.com/google/code-prettify -->

    </body>
</html>
